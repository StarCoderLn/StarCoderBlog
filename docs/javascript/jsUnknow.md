## :books: 作用域是什么

### :blue_book: 作用域出现的背景

几乎所有编程语言最基本的功能之一，就是能够储存变量中的值，并且能在之后对这个值进行访问或修改。**正是这种储存和访问变量的能力将状态带给了程序**。

但是将变量引入程序会引起一些问题，比如，这些变量储存在哪里？程序需要时如何找到它们？

为了解决这些问题，就需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量。这套规则被称为**作用域**。

### :blue_book: 编译原理

在传统编译语言的流程中，程序中的一段源代码在执行前会经历三个步骤，统称为“**编译**”。

- :gem: **分词/词法分析（Tokenizing/Lexing）**

  这个过程会将由字符组成的字符串分解成（对编译语言来说）有意义的代码块，这些代码块被称为**词法单元（token）**。

  例如，考虑程序 var a = 2;。这段程序通常会被分解成为下面这些词法单元：var、a、=、2 、;。**空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义**。

  ::: warning 注意
  分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于**词法单元的识别是通过有状态还是无状态的方式进行的**。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是**有状态的解析规则**，那么这个过程就**被称为词法分析**。
  :::

- :gem: **解析/语法分析（Parsing）**

  这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“**抽象语法树**”（Abstract Syntax Tree，`AST`）。

  var a = 2; 的抽象语法树中可能会有一个叫作 `VariableDeclaration` 的顶级节点，接下来是一个叫作 `Identifier`（它的值是 a）的子节点，以及一个叫作 `AssignmentExpression` 的子节点。AssignmentExpression 节点有一个叫作 `NumericLitral` （它的值是2）的子节点。

- :gem: **代码生成**

  **将 AST 转换为可执行代码的过程被称为代码生成**。这个过程**与语言、目标平台等息息相关**。

  抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。

比起那些编译过程只有三个步骤的语言的编译器，**JavaScript 引擎要复杂得多**。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

首先，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，**JavaScript 的编译过程不是发生在构建之前的**。

对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 `JIT`，可以延迟编译甚至实施重编译）来保证性能最佳。

简单地说，**任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）**。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。

### :blue_book: 理解作用域

在对程序 var a = 2; 的处理过程中，引擎、编译器和作用域分别负责重要的任务：

- :gem: **引擎**

  从头到尾负责整个 JavaScript 程序的编译及执行过程。

- :gem: **编译器**

  负责语法分析及代码生成等。

- :gem: **作用域**

  负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

当前引擎碰见 var a = 2; 这段程序时，它会认为这里有两个完全不同的声明，**一个由编译器在编译时处理，另一个由引擎在运行时处理**。

下面我们将 var a = 2; 分解，看看引擎和它的朋友们是如何协同工作的。

编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。

事实上编译器会进行如下处理。

1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。

如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！

:pencil: 总结：变量的赋值操作会执行两个动作，**首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值**。

### :blue_book: LHS 与 RHS

编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是**引擎执行怎样的查找，会影响最终的查找结果**。

查询的方式有两种：`LHS` 查询和 `RHS` 查询。

其中，L 和 R 的含义是**一个赋值操作的左侧和右侧**。

可以简单理解成，当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。

但其实更准确的理解是，**RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图找到变量的容器本身，从而可以对其赋值**。从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“**非左侧**”。

看下面的例子：

```js
console.log(a)
```

这里对 a 的引用是一个 RHS 引用，因为这里的 a 并没有赋予任何值。相反，需要查找并取得 a 的值，这样才能将值传递给 console.log(...)。

再看另外一个例子：

```js
a = 2;
```

这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 =2 这个赋值操作找到一个目标。

LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此，LHS 和 RHS 按下面的方式来理解最为适合：

:bell: LHS：**赋值操作的目标是谁**。

:bell: RHS：**谁是赋值操作的源头**。

下面这段程序中，既有 LHS 也有 RHS 引用：

```js
function foo(a) {
  console.log(a); // 2
}
foo(2);
```

最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，意味着“去找到 foo 的值，并把它给我”。

但是，代码中隐式的 a＝2 操作可能很容易被忽略掉。这个操作发生在 2 被当作参数传递给 foo(..) 函数时，2 会被分配给参数 a。为了给参数 a（隐式地）分配值，需要进行一次 LHS 查询。

这里还有对 a 进行的 RHS 引用，并且将得到的值传给了 console.log(..)。console. log(..) 本身也需要一个引用才能执行，因此会对 console 对象进行 RHS 查询，并且检查得到的值中是否有一个叫作 log 的方法。

### :blue_book: 小测验

```js
function foo(a) {
  var b = a;
  return a + b;
}
var c =foo(2);
```

1、找到其中所有的 LHS 查询。（有3处）

> 答案：c = ..;、a = 2（隐式变量分配）、b = ..

2、找到其中所有的 RHS 查询。（有4处）

> 答案：foo(2..、= a;、a ..、.. b

### :blue_book: 作用域嵌套

通过前面的学习知道，**作用域是根据名称查找变量的一套规则**。实际情况中，通常需要同时顾及几个作用域。

:bell: **当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。**

看下面这个例子：

```js
function foo(a) {
  console.log(a + b);
}
var b = 2;
foo(2); // 4
```

对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域（在这个例子中就 是全局作用域）中完成。

:bell: 遍历嵌套作用域链的规则很简单：**引擎从当前的执行作用域开始查找变量，如果找不到， 就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止**。

### :blue_book: 异常

区分 LHS 和 RHS 是一件很重要的事情，因为**在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的**。

看下面的代码：

```js
function foo(a) {
  console.log(a + b);
  b = a;
}
foo(2);
```

第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。

:bell: **如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 `ReferenceError` 异常**。值得注意的是，ReferenceError 是非常重要的异常类型。

:bell: 相比之下，**当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下**。

ES5 中引入了“严格模式”。同正常模式，或者说宽松/懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是**严格模式禁止自动或隐式地创建全局变量**。因此，在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。

如果 RHS 查询找到了一个变量，但是你**尝试对这个变量的值进行不合理的操作**， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 `TypeError`。

:bell: **ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的**。

### :blue_book: 总结

1. 作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。

2. 如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。

3. 赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

4. JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤：

   （1）首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。  

   （2）接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。

5. LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

6. 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。


## :books: 词法作用域

通过前面的学习可知，作用域是一套规则，它用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

作用域共有两种主要的工作模型：

:bell: **词法作用域**，这是最为普遍的，被大多数编程语言所采用的。

:bell: **动态作用域**，这种仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。

### :blue_book: 词法阶段

大部分标准语言编译器的第一个工作阶段叫作**词法化**（也叫**单词化**）。**词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义**。这个概念是理解词法作用域及其名称来历的基础。

:bell: **词法作用域就是定义在词法阶段的作用域**。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。

比如下面这个例子：

```js
function foo(a) {
  var b = a * 2;
  function bar(c) {
    console.log(a, b, c);
  }
  bar(b * 3);
}
foo(2); // 2, 4, 12
```

在这个例子中有三个逐级嵌套的作用域。可以将它们想象成几个逐级包含的气泡。

![jsunknow](../.vuepress/public/assets/image/javascript/jsunknow1.png 'jsunknow')

:one: 包含着整个全局作用域，其中只有一个标识符：foo。

:two: 包含着 foo 所创建的作用域，其中有三个标识符：a、bar 和 b。

:three: 包含着 bar 所创建的作用域，其中只有一个标识符：c。

作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的。

::: warning 注意
这里所说的气泡是严格包含的。也就是说，没有任何函数的气泡可以（部分地）同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。
:::

#### :gem: 查找变量

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

在上面那个例子中，引擎执行 console.log(..) 声明，并查找 a、b 和 c 三个变量的引用。它首先从最内部的作用域，也就是 bar(..) 函数的作用域气泡开始查找。引擎无法在这里找到 a，因此会去上一级到所嵌套的 foo(..) 的作用域中继续查找。在这里找到了 a， 因此引擎使用了这个引用。对 b 来讲也是一样的。而对 c 来说，引擎在 bar(..) 中就找到了它。

如果 a、c 都存在于 bar(..) 和 foo(..) 的内部，console.log(..) 就可以直接使用 bar(..) 中的变量，而无需到外面的 foo(..) 中查找。

:bell: **作用域查找会在找到第一个匹配的标识符时停止**。

#### :gem: 遮蔽效应

在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（**内部的标识符“遮蔽”了外部的标识符**）。

抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。

::: warning 注意
全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。

window.a

通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。
:::

无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

:bell: **词法作用域查找只会查找一级标识符**，比如 a、b 和 c。如果代码中引用了 foo.bar.baz， 词法作用域查找只会试图查找 foo 标识符，找到这个变量后，**对象属性访问规则**会分别接管对 bar 和 baz 属性的访问。

### :blue_book: 欺骗词法

JavaScript 中有两种机制可以实现在运行时“修改”（也可以说欺骗）词法作用域：

:bell: **eval**

:bell: **with**

::: warning 注意
欺骗词法作用域会导致性能下降。
:::

#### :gem: eval

eval(..) 函数接受一个字符串为参数，它可以在你写的代码中用程序生成代码并运行，就好像代码本来就是写在那个位置的一样。

在执行 eval(..) 之后的代码时，引擎并不 “知道” 或 “在意” 前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。

比如下面这个例子：

```js
function foo(str, a) {
  eval(str); // 欺骗
  console.log(a, b)
}
var b = 2;
foo('var b = 3;', 1) // 1  3
```

eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实上，和前面提到的原理一样，**这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽了外部（全局）作用域中的同名变量**。

当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b。因此会输出 “1, 3” 而不是正常情况下会输出的 “1, 2”。

**eval(..) 通常被用来执行动态创建的代码**。默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明（无论是变量还是函数），就会对 eval(..) 所处的词法作用域进行修改。

技术上，通过一些技巧（已经超出我们的讨论范围）可以间接调用 eval(..) 来使其运行在全局作用域中，并对全局作用域进行修改。

但无论何种情况，**eval(..) 都可以在运行期修改书写期的词法作用域**。

::: warning 注意

在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。

```js
function foo(str) {
  "use strict";
  eval(str);
  console.log(a); // ReferenceError: a is not defined
}
foo("var a = 2");
```
:::

JavaScript 中还有其他一些功能效果和 eval(..) 很相似。setTimeout(..) 和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。

::: warning 注意

这些功能已经过时且并不被提倡。不要使用它们！

:::

new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）。**这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用**。

在程序中动态生成代码的使用场景非常罕见，因为**它所带来的好处无法抵消性能上的损失**。

#### :gem: with

可以有很多种方法来解释 with，在这里从这个角度来解释它：它如何同被它所影响的词法作用域进行交互。

:bell: **with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身**。

比如：

```js
var obj = {
  a: 1,
  b: 2,
  c: 3
}

// 单调乏味的重复 obj
obj.a = 2
obj.b = 3
obj.c = 4

// 简单的快捷方式
with (obj) {
  a = 3
  b = 4
  c = 5
}
```

但实际上这不仅仅是为了方便地访问对象属性。看下面这个例子：

```js
function foo (obj) {
  with (obj) {
    a = 2
  }
}

var o1 = {
  a: 3
}

var o2 = {
  b: 3
}

foo(o1)
console.log(o1.a) // 2

foo(o2)
console.log(o2.a) // undefined
console.log(a) // 2 —— a 被泄漏到全局作用域上了！
```

这个例子中创建了 o1 和 o2 两个对象。其中一个具有 a 属性，另外一个没有。foo(..) 函 数接受一个 obj 参数，该参数是一个对象引用，并对这个对象引用执行了 with(obj) {..}。 在 with 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个 LHS 引用，并将 2 赋值给它。

当我们将 o1 传递进去，a ＝ 2 赋值操作找到了 o1.a 并将 2 赋值给它。而当 o2 传递进去，o2 并没有 a 属性，因此不会创建这个属性， o2.a 保持 undefined。

但是此时却产生了一个奇怪的副作用，**实际上 a = 2 赋值操作创建了一个全局的变量 a**。

:bell: **with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符**。

::: warning 注意
尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。
:::

:bell: **eval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域**。

可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符， 因此**进行了正常的 LHS 标识符查找**。

o2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a＝2 执行时，自动创建了一个全局变量（因为是非严格模式）。

::: warning 注意
另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响（限制）。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。
:::

#### :gem: 性能

JavaScript 引擎会在编译阶段进行数项的性能优化。其中**有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符**。

但**如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的**，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。

:bell: **因此如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢**。

### :blue_book: 总结

1. 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。

2. JavaScript 中有两个机制可以 “欺骗” 词法作用域：eval(..) 和 with。

   前者可以对一段包含一个或多个声明的 “代码” 字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。

   后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

3. 这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们！

## :books: 函数作用域和块作用域

通过前面的学习可知，作用域包含了一系列 “气泡”，那么，究竟是什么生成了一个新的气泡？只有函数会生成新的气泡吗？ JavaScript 中的其他结构能生成作用域气泡吗？

### :blue_book: 函数中的作用域

要回答上面的问题，需要先研究一下函数作用域及其背后的一些内容。

看下面这段代码：

```js
function foo (a) {
  var b = 2
  // 一些代码
  function bar () {
    // ...
  }
  // 更多代码
  var c = 3
}
```

在这个代码片段中，foo(..) 的作用域气泡中包含了标识符 a、b、c 和 bar。无论标识符声明出现在作用域中的何处，这个标识符所代表的变量或函数都将附属于所处作用域的气泡。

bar(..) 拥有自己的作用域气泡。全局作用域也有自己的作用域气泡，它只包含了一个标识符：foo。

由于标识符 a、b、c 和 bar 都附属于 foo(..) 的作用域气泡，因此无法从 foo(..) 的外部对它们进行访问。也就是说，这些标识符全都无法从全局作用域中进行访问，因此下面的代码会导致 ReferenceError 错误：

```js
bar() // 失败
console.log(a, b, c) // 三个都失败
```

但是，这些标识符（a、b、c、foo 和 bar）在 foo(..) 的内部都是可以被访问的，同样在 bar(..) 内部也可以被访问（假设 bar(..) 内部没有同名的标识符声明）。

:bell: **函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）**。

这种设计方案是非常有用的，能充分利用 JavaScript 变量可以根据需要改变值类型的 “动态” 特性。

但与此同时，如果不细心处理那些可以在整个作用域范围内被访问的变量，可能会带来意 想不到的问题。

### :blue_book: 隐藏内部实现

对函数的传统认知就是先声明一个函数，然后再向里面添加代码。但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。

实际的结果就是在这个代码片段的周围创建了一个作用域气泡，也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。换句话说，**可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来 “隐藏” 它们**。

为什么 “隐藏” 变量和函数是一个有用的技术？

有很多原因促成了这种基于作用域的隐藏方法。

:bell: 它们大都是从**最小特权原则**中引申出来的，也叫**最小授权或最小暴露原则**。这个原则是指**在软件设计中，应该最小限度地暴露必要内容，而将其他内容都 “隐藏” 起来，比如某个模块或对象的 API 设计**。

这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。

比如：

```js
function doSomething (a) {
  b = a + doSomethingElse(a * 2)
  console.log(b * 3)
}
function doSomethigElse (a) {
  return a - 1
}
var b
doSomethig(2) // 15
```

在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体实现的 “私有” 内容。给予外部作用域对 b 和 doSomethingElse(..) 的 “访问权限” 不仅没有必要，而且可能是 “危险” 的，因为它们可能被有意或无意地以非预期的方式使用， 从而导致超出了 doSomething(..) 的适用条件。更 “合理” 的设计会将这些私有的具体内容隐藏在 doSomething(..) 内部，例如：

```js
function doSomething (a) {
  function doSomethingElse (a) {
    return a - 1
  }
  var b
  b = a + doSomethingElse(a * 2)
}
doSmoething(2) // 15
```

现在，b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。 功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。

#### :gem: 规避冲突

:bell: “隐藏”作用域中的变量和函数所带来的另一个好处，是**可以避免同名标识符之间的冲突**。

两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。**冲突会导致变量的值被意外覆盖**。

比如：

```js
function foo () {
  function bar (a) {
    i = 3 // 修改 for 循环所属作用域的 i
    console.log(a + i)
  }
  for (var i = 0; i < 10; i++) {
    bar(i * 2) // 陷入死循环中！
  }
}
foo()
```

bar(..) 内部的赋值表达式 i = 3 意外地覆盖了声明在 foo(..) 内部 for 循环中的 i。在这个例子中将会导致无限循环，因为 i 被固定设置为 3，永远满足小于 10 这个条件。

解决这个问题的方法是，bar(..) 内部的赋值操作需要声明一个本地变量来使用，采用任何名字都可以 var i = 3 就可以满足这个需求（**同时会为 i 声明一个前面提到过的“遮蔽变量”**）。另外一种方法是采用一个完全不同的标识符名称，比如 var j = 3。

但是软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。

规避冲突的常见方法有以下两种：

**1. 全局命名空间**

很多第三方库通常会**在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性**，而不是将自己的标识符暴漏在顶级的词法作用域中。

比如：

```js
var MyReallyCoolLibrary = {
  awesome: 'stuff',
  doSomething: function () {
    // ...
  },
  doAnotherThing: function () {
    // ...
  }
}
```

**2. 模块管理**

这种方法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来使用。使用这些工具，任何库都无需将标识符加入到全局作用域中，而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。

这些工具并没有能够违反词法作用域规则的“神奇”功能。**它们只是利用作用域的规则强制所有标识符都不能注入到共享作用域中**，而是保持在私有、无冲突的作用域中，这样可以有效规避掉所有的意外冲突。

不过，即使不使用任何依赖管理工具也可以实现相同的功效。


### :blue_book: 函数作用域

我们已经知道，在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容。

比如：

```js
var a = 2

function foo () {
  var a = 3
  console.log(a) // 3
}
foo()

console.log(a) // 2
```

虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。

- 首先，必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。

- 其次，必须显式地通过函数名（foo()）调用这个函数才能运行其中的代码。

如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想。

JavaScript 提供了能够同时解决这两个问题的方案：

```js
var a = 2;

(function foo () {
  var a = 3
  console.log(a) // 3
})()
console.log(a) // 2
```

:question: 我运行这段代码，发现并不像书中说的打印2，而是会报 Uncaught TypeError: 2 is not a function 的错误，不知道为啥。

:exclamation: 找到原因了！原来是因为第一行 var a = 2 没带分号，导致立即执行函数执行时把2也当成一个函数去执行了！所以把分号还回去就没问题了。以后要注意，:bell: **立即执行函数前面声明变量时不要省略分号！**

在这段代码中，包装函数的声明以 `(function...` 而不仅是以 `function...` 开始，这是一个很重要的区别。:bell: **函数会被当作函数表达式而不是一个标准的函数声明来处理**。

::: warning 注意
区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。
:::

函数声明和函数表达式之间最重要的区别是**它们的名称标识符将会绑定在何处**。

第一段代码中 foo 被绑定在所在作用域中，可以直接通过 foo() 来调用它。第二段代码中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。

换句话说，(function foo(){ .. }) 作为函数表达式意味着 **foo 只能在 .. 所代表的位置中被访问，外部作用域则不行**。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。

#### :gem: 匿名和具名

对于函数表达式最熟悉的场景可能就是回调函数了，比如：

```js
setTimeout(function () {
  console.log('I waited 1 second!')
}, 1000)
```

这叫**匿名函数表达式**，因为 function().. 没有名称标识符。

:bell: **函数表达式可以是匿名的， 而函数声明则不可以省略函数名 —— 在 JavaScript 的语法中这是非法的**。

匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但它有几个缺点：

1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。

2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。

3. 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

:bell: **行内函数表达式**

给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：

```js
setTimeout(function timeoutHandler () {
  console.log('I waited 1 second!')
}, 1000)
```

#### :gem: 立即执行函数表达式

```js
(function () {
  // ...
})()

// 或者

(function () {
  // ...
}())
```

第一种形式中第一个 () 将函数变成表达式，第二个 () 执行了这个函数。

第二种形式中用来调用的 () 括号被移进了用来包装的 ( ) 括号中。

这两种形式在功能上是一样的，立即执行表达式有一个术语：`IIFE`。

::: warning 注意
函数名对 IIFE 当然不是必须的，IIFE 最常见的用法是使用一个匿名函数表达式。虽然使用具名函数的 IIFE 并不常见，但它具有上述匿名函数表达式的所有优势，因此也是一个值得推广的实践。
:::

IIFE 的另一个非常普遍的进阶用法是**把它们当作函数调用并传递参数进去**。

```js
var a = 2;

(function IIFE (global) {
  var a = 3
  console.log(a) // 3
  console.log(global.a) // 2
})(window)

console.log(a) // 2
```

这个模式的另外一个应用场景是**解决 undefined 标识符的默认值被错误覆盖导致的异常（虽然不常见）**。将一个参数命名为 undefined，但是在对应的位置不传入任何值，这样就可保证在代码块中 undefined 标识符的值真的是 undefined：

```js
undefined = true; // 给其他代码挖了一个大坑！绝对不要这样做！

(function IIFE (undefined) {
  var a
  if (a === undefined) {
    console.log('Undefined is safe here!')
  }
})()
```

IIFE 还有一种变化的用途是**倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去**。这种模式在 UMD（Universal Module Definition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。

```js
var a = 2;

(function IIFE (def) {
  def(window)
})(function def (global) {
  var a = 3
  console.log(a) // 3
  console.log(global.a) // 2
})
```

函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进 IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将 window 传入当作 global 参数的值。

### :blue_book: 块作用域

除 JavaScript 外的很多编程语言都支持块作用域，因此其他语言的开发者对于相关的思维方式会很熟悉，但是对于主要使用 JavaScript 的开发者来说，这个概念会很陌生。

先看一个例子：

```js
for (var i = 0; i < 10; i++) {
  console.log(i)
}
```

我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 **i 会被绑定在外部作用域（函数或全局）中**的事实。

再看另一个例子：

```js
var foo = true

if (foo) {
  var bar = foo * 2
  bar = something(bar)
  console.log(bar)
}
```

bar 变量仅在 if 声明的上下文中使用，因此如果能将它声明在 if 块内部中会是一个很有意义的事情。但是，当使用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域。这段代码是为了风格更易读而伪装出的形式上的块作用域，如果使用这种形式，要确保没在作用域其他地方意外地使用 bar 只能依靠自觉性。

:bell: **块作用域是一个用来对之前的最小授权原则进行扩展的工具，将代码从在函数中隐藏信息 扩展为在块中隐藏信息**。

JavaScript 中能够提供块级作用域功能的方法有以下几种：

#### :gem: with

with 不仅是一个难于理解的结构，同时也是块作用域的一个例子（块作用域的一种形式），用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。

#### :gem: try/catch

JavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。

比如：

```js
try {
  undefined() // 执行一个非法操作来强制制造一个异常
} catch (err) {
  console.log(err) // 能够正常执行
}
console.log(err) // ReferenceError: err not found
```

可见，err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。

::: warning 注意
尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境（除了老版本的 IE 浏览器）所支持，但是当同一个作用域中的两个或多个 catch 分句用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部，但是静态检查工具还是会很烦人地发出警告。

为了避免这个不必要的警告，很多开发者会将 catch 的参数命名为 err1、err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查。
:::

#### :gem: let

let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，**let 为其声明的变量隐式地绑定了所在的块作用域**。

```js
var foo = true

if (foo) {
  let bar = foo * 2
  bar = something(bar)
  console.log(bar)
}

console.log(bar) // ReferenceError
```

用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。

在开发和修改代码的过程中，如果没有密切关注哪些块作用域中有绑定的变量，并且习惯性地移动这些块或者将其包含在其他的块中，就会导致代码变得混乱。

为块作用域显式地创建块可以部分解决这个问题，使变量的附属关系变得更加清晰。**通常来讲，显式的代码优于隐式或一些精巧但不清晰的代码**。显式的块作用域风格非常容易书写，并且和其他语言中块作用域的工作原理一致：

```js
var foo = true

if (foo) {
  { // 显示的块
    let bar = foo * 2
    bar = something(bar)
    console.log(bar)
  }
}

console.log(bar) // ReferenceError
```

只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑定的块。

使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不 “存在”。比如：

```js
{
  console.log(bar) // ReferenceError
  let bar = 2
}
```

**1. 垃圾收集**

另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。

看下面的代码：

```js
function process (data) {
  // ...
}

var someReallyBigData = { ... }

process(someReallyBigData)

var btn = document.getElementById('my_button')

btn.addEventListener('click', function click (evt) {
  console.log('button clicked')
}, /*capturingPhase*/false)
```

click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构（取决于具体实现）。

块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了：

```js
function process (data) {
  // ...
}

{ // 在这个块中定义的内容可以销毁了！
  var someReallyBigData = { ... }

  process(someReallyBigData)
}

var btn = document.getElementById('my_button')

btn.addEventListener('click', function click (evt) {
  console.log('button clicked')
}, /*capturingPhase*/false)
```

**2. let 循环**

一个 let 可以发挥优势的典型例子就是之前讨论的 for 循环。

```js
for (let i = 0; i < 10; i++) {
  console.log(i)
}
console.log(i) // ReferenceError
```

for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，**事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值**。

下面通过另一种方式来说明每次迭代时进行重新绑定的行为：

```js
{
  let j
  for (j = 0; j < 10; j++) {
    let i = j // 每个迭代重新绑定
    console.log(i)
  }
}
```

#### :gem: const

const 同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

```js
var foo = true

if (foo) {
  var a = 2
  const b = 3

  a = 3 // 正常
  b = 4 // 错误，TypeError
}

console.log(a) // 3
console.log(b) // ReferenceError
```

### :blue_book: 总结

1. 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。

2. 但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。

3. 从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域。

4. 在 ES6 中引入了 let 关键字（var 关键字的表亲），用来在任意代码块中声明变量。if (..) { let a = 2; } 会声明一个劫持了 if 的 { .. } 块的变量，并且将变量添加到这个块中。

5. 有些人认为块作用域不应该完全作为函数作用域的替代方案。两种功能应该同时存在，开发者可以并且也应该根据需要选择使用何种作用域，创造可读、可维护的优良代码。